---
title: for loops
format:
  live-html:
    pyodide:
      cell-options:
        autorun: false
        completion: true
---

## Resources

- [for](https://docs.python.org/3/tutorial/controlflow.html#for-statements) statement in the official documentation.
- [for loops](https://realpython.com/python-for-loop/) in Real Python.

## for

for allows us to execute a [block](block.qmd) of code for each item.
The variable defined after the for keyword will take the value of each item, one at a time, one for each iteration.

```{pyodide}
salutations = ["Hello", "hi", "Ciao"]

for salutation in salutations:
    # The variable salutation will have each of the strings,
    # one at a time, until the given list of saluations runs
    # out of strings.
    print(salutation)
print("for loop done!")
```

What would happen if we executed the following code? How would you fix it?

```{pyodide}
#| exercise: for_block
salutations = ["Hello", "hi", "Ciao"]

for salutation in salutations:
    print(salutation)
    print("for loop done!")
```

::: { .solution exercise="for_block" }
::: { .callout-tip collapse="false"}

```{pyodide}
for salutation in salutations:
    print(salutation)
print("for loop done!")
```

:::
:::

Internally the for loop works by calling the [next](https://docs.python.org/3/library/functions.html#next) on an [iterator](https://docs.python.org/3/glossary.html#term-iterator) from the given [iterable](https://docs.python.org/3/glossary.html#term-iterable).
An iterator is an object that supports the generation of one item at a time when given to the next function until it runs out of items.
So the previous for would be, more or less, equivalent running the following code.

```{pyodide}

salutations = iter(["Hello", "hi", "Ciao"])

# This for is equivalent of doing
salutations = iter(salutations)
salutation = next(salutation)
print(salutation)
salutation = next(salutation)
print(salutation)
salutation = next(salutation)
print(salutation)
salutation = next(salutation)
print(salutation)

```

This kind of for loop, the one implemented in the Python, in other languages is known as a [foreach](https://en.wikipedia.org/wiki/Foreach_loop) loop.
To have the functionallity available in other programming languages, in which the for statement just iterates over some numbers, you could combine a for loop with the [range](https://docs.python.org/3/library/functions.html#func-range) function.

Write a for loop that prints the first 10 natural numbers.

```{pyodide}
#| exercise: for_numbers

# expected result
# 0
# 1
# 2
# 3
# 4
# 5
# 6
# 7
# 8
# 9
# Done!
```

::: { .hint exercise="for_numbers"}
::: { .callout-note collapse="false"}

You can use a list or the [range](https://docs.python.org/3/library/functions.html#func-range) function.

:::
:::

::: { .solution exercise="for_numbers"}
::: { .callout-note collapse="false"}

With a list.

```{pyodide}
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
for i in numbers:
    print(i)
print("Done!")
```

With the range function.

```{pyodide}

for i in range(10):
    print(i)
print("Done!")
```

:::
:::

Create a program that writes the following:

```{pyodide}
#| exercise: number_lists
1 
1 2 
1 2 3 
1 2 3 4 
1 2 3 4 5
```

::: { .solution exercise="number_lists"}
::: { .callout-note collapse="false"}

There are many ways of solving this exercise, here you have some.


```{pyodide}
numbers = []
for i in [1, 2, 3, 4, 5]:
    numbers.append(str(i))
    print(' '.join(numbers))
```

```{pyodide}
for i in range(1, 6):
    numbers = list(range(1, i + 1))
    number_strs = []
    for number in numbers:
        number_strs.append(str(number))
    print(' '.join(number_strs))
```

Using [map](https://docs.python.org/3/library/functions.html#map) and [range](https://docs.python.org/3/library/functions.html#func-range).

```{pyodide}
for i in range(1, 6):
    numbers = map(str, range(1, i + 1))
    print(' '.join(numbers))
```

Using a [list comprenhension](https://realpython.com/list-comprehension-python/).

```{pyodide}
for i in range(1, 6):
    numbers = [str(number) for number in range(1, i + 1)]
    print(' '.join(numbers))
```

:::
:::

Additionally, Python has a [while](https://docs.python.org/3/reference/compound_stmts.html#the-while-statement) statement, another way of doing loops.

## break

During at any moment the loop could be stopped, broken, by using [break](https://docs.python.org/3/reference/simple_stmts.html#break).

```{pyodide}

for i in [1, 2, 3]:
    print(i)
    break # only the first number will be printed
    print("This line won't be printed")
print("All done!")

```

## continue

The continue statement allows us to move to the next iteration without running the rest of the code in the block.

```{pyodide}

for i in [1, 2, 3, 4]:
    print(i)
    continue
    print("This line will never be printed.")
print("All done!")

```

```{pyodide}

for i in [1, 2, 3, 4]:
    if i % 2:
        continue
    print("Only the even numbers will be printed: ", i)
print("All done!")

```

## enumerate

It is quite common to need both the item and its index. We could do it like:

```{pyodide}

i = 0
for word in ["resistance", "is", "futile"]:
    print(f"This is the word number: {i} - word")
    i += 1

```

However, this is a pattern so common that Python have solved it by using the function [enumerate](https://docs.python.org/3/library/functions.html#enumerate).

```{pyodide}

for i, word in enumerate(["Live", "long", "and", "prosper"]):
    print(f"This is the word number: {i} - word")

```

Enumerate works by creating an iterator of tuples with two elements: the index, and the original item.

```{pyodide}

words = ["Beam", "me", "up", "Scotty"]
enumerate_tuples = list(enumerate(words))
print(enumerate_tuples)

```

And since Python supports mutiple assigment what we are doing in the for loop is equivalente to:

```{pyodide}
words = ["Highly", "illogical"]
tuples = enumerate(words)
tuple_ = next(tuples)
print(tuple_)
i, word = tuple
print(i, word)
tuple_ = next(tuples)
print(tuple_)
i, word = tuple
print(i, word)
```

## for exercises

Print the multiplication table for a given number.

```{pyodide}
#| exercise: multiplication_table

number = 7
```

::: { .solution exercise="multiplication_table" }
::: { .callout-tip collapse="false"}

```{pyodide}
number = 7
for i in range(1, 11):
    result = number * i
    print(f"{number} * {i} = {result}")
```

:::
:::


Sum all numbers from 1 to a given number.

```{pyodide}
#| exercise: sum_numbers

# For example, if the number is 5, then 1 + 2 + 3 + 4 + 5
number = 5

```

::: { .solution exercise="sum_numbers" }
::: { .callout-tip collapse="false"}

```{pyodide}
number = 5
sum_so_far = 0
for i in range(1, number + 1):
    sum_so_far += i
print(sum_so_far)
```

```{pyodide}
number = 5
print(sum(range(1, number + 1)))
```

:::
:::

Calculate the factorial for a number.

```{pyodide}
#| exercise: factorial
# For example, if the number is 5, then 1 * 2 * 3 * 4 * 5
number = 5

```

::: { .solution exercise="factorial" }
::: { .callout-tip collapse="false"}

```{pyodide}
number = 5

factorial_so_far = 1
for i in range(1, number + 1):
    factorial_so_far *= i
print(factorial_so_far)
```

Using a functional approach with [reduce](https://realpython.com/python-reduce-function/).

```{pyodide}
from functools import reduce
from operator import mul
number = 5
print(reduce(mul,range(1, number + 1)))
```

:::
:::

Create a program that given a list of words prints if they are short (less than 4 characters long), not so long (between 4 and 7 characters), and very long (more than 7 characters).

```{pyodide}
#| exercise: long_words
foods = ['bacon', 'tuna', 'ham', 'sausages', 'beef']
for food in foods:
    ...
# The expected result is
# bacon is a not so long word
# tuna is a not so long word
# ham is a short word
# sausages is a long word
# beef is a not so long word
```

::: { .hint exercise="long_words" }
::: { .callout-tip collapse="false"}

Remember that you can use the [len](https://docs.python.org/3/library/functions.html#len) function to get the number of characters of a string and you could create an if, elif, else.

:::
:::

::: { .solution exercise="long_words" }
::: { .callout-tip collapse="false"}

```{pyodide}
foods = ['bacon', 'tuna', 'ham', 'sausages', 'beef']
for food in foods:
    len_food = len(food)
    if len_food < 4:
        print(f"{food} is a short word")
    elif len_food <=7:
        print(f"{food} is a not so long word")
    else:
        print(f"{food} is a long word")
```

:::
:::

Write a program that outputs which people were a Beatle member and their index in the list.

```{pyodide}
#| exercise: beatles_for

people = ['Brian', 'George', 'John', 'Little', 'Paul', 'Pete', 'Ringo', 'Stuart']  
beatles= ['John', 'Paul', 'George', 'Ringo']

for index, person in people:
    ...

```

::: { .hint exercise="beatles_for" }
::: { .callout-tip collapse="false"}

Remember that you can use enumerate to get the index in any for, and that the in operator allows you to check if an item is in a list.

:::
:::

::: { .solution exercise="beatles_for" }
::: { .callout-tip collapse="false"}

```{pyodide}
people = ['Brian', 'George', 'John', 'Little', 'Paul', 'Pete', 'Ringo', 'Stuart']  
beatles= ['John', 'Paul', 'George', 'Ringo']

for index, person in enumerate(people):
    if person in beatles:
        print(f'{person}, number {index} in the list is a Beatle')
```

If the list were large it would be much efficient to use a dictionary or a [set](https://docs.python.org/3/tutorial/datastructures.html#sets) than a list.
The solution using a set would be:

```{pyodide}
people = ['Brian', 'George', 'John', 'Little', 'Paul', 'Pete', 'Ringo', 'Stuart']  
beatles= set(['John', 'Paul', 'George', 'Ringo'])

for index, person in enumerate(people):
    if person in beatles:
        print(f'{person}, number {index} in the list is a Beatle')
```

Using [filter](https://docs.python.org/3/library/functions.html#filter) and a lambda we could even skip many iterations of the for.

```{pyodide}
people = ['Brian', 'George', 'John', 'Little', 'Paul', 'Pete', 'Ringo', 'Stuart']  
beatles= set(['John', 'Paul', 'George', 'Ringo'])

for index, person in filter(lambda idx_person: idx_person[1] in beatles, enumerate(people)):
    print(f'{person}, number {index} in the list is a Beatle')
```

:::
:::

We are reading a comma-separated values ([CSV](https://en.wikipedia.org/wiki/Comma-separated_values)) text file.
In each file we have measures and we want to calculate the mean value.

```{pyodide}
#| exercise: mean_value

line = "13.5,34.5,23.6,45.7,23.0"

print(mean)

```

::: { .hint exercise="mean_value" }
::: { .callout-tip collapse="false"}

Remember that the str split method can split a text string into a list and the float funtion can transform a text into a number.

:::
:::

::: { .solution exercise="mean_value" }
::: { .callout-tip collapse="false"}

```{pyodide}
line = "13.5,34.5,23.6,45.7,23.0"
num_numbers = 0
total = 0
for text_number in line.split(","):
    total += float(text_number)
    num_numbers += 1
mean = total / num_numbers
print(mean)
```

Alternativerly you could use the [map](https://docs.python.org/3/library/functions.html#map) and [sum](https://docs.python.org/3/library/functions.html#sum) functions.

```{pyodide}
line = "13.5,34.5,23.6,45.7,23.0"
numbers = list(map(float, line.split(",")))
mean = sum(numbers) / len(numbers)
print(mean)
```

Or the [mean](https://docs.python.org/3/library/statistics.html#statistics.mean) function and a [list comprenhension](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions).

```{pyodide}
from statistics import mean
line = "13.5,34.5,23.6,45.7,23.0"
numbers = [float(text_number) for text_number in line.split(",")]
print(mean(numbers))
```

:::
:::

Write a program that stores all the multiples of 7 from 1 to n.

```{pyodide}
#| exercise: multiple7
n = 25

multiples = []



print(multiples)
```

::: { .hint exercise="multiple7" }
::: { .callout-tip collapse="false"}

Remember that you can use the [range](https://docs.python.org/3/library/functions.html#func-range) function to get the numbers and the [modulo](https://realpython.com/python-modulo-operator/) operator to get the remainder of an integer division.

:::
:::

::: { .solution exercise="multiple7" }
::: { .callout-tip collapse="false"}

```{pyodide}
n = 25

multiples = []
for number in range(1, n):
  if not number % 7:
    multiples.append(number)
print(multiples)
```

Alternatively, it could be solved using [filter](https://docs.python.org/3/library/functions.html#filter) and a lambda function.

```{pyodide}
n = 25

multiples = list(filter(lambda number: not number %7, range(1, n)))
print(multiples)

```

Or a [list comprenhension](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions) (this is a very common style that you will find in Python code).

```{pyodide}
n = 25
multiples = [number for number in range(1, 25) if not number % 7]
print(multiples)
```

:::
:::

Create a program that collects the quotes from each author in different lists.

```{pyodide}
#| exercise: phil_quotes

text = '''Plato: Never discourage anyone who continually makes progress, no matter how slow.
Plato: The beginning is the most important part of the work.
Socrates: To find yourself, think for yourself.
Aristotle: It is the mark of an educated mind to be able to entertain a thought without accepting it.
Aristotle: The more you know, the more you realize you don't know.'''

socrates_quotes = []
plato_quotes = []
aristotle_quotes = []

for line in text.splitlines():
    ...

```

::: { .solution exercise="phil_quotes" }
::: { .callout-tip collapse="false"}

```{pyodide}
text = '''Plato: Never discourage anyone who continually makes progress, no matter how slow.
Plato: The beginning is the most important part of the work.
Socrates: To find yourself, think for yourself.
Aristotle: It is the mark of an educated mind to be able to entertain a thought without accepting it.
Aristotle: The more you know, the more you realize you don't know.'''

socrates_quotes = []
plato_quotes = []
aristotle_quotes = []

for line in text.splitlines():
  author, quote = line.split(':')
  author = author.lower()
  quote = quote.strip()
  if author == "socrates":
    socrates_quotes.append(quote)
  elif author == "plato":
    plato_quotes.append(quote)
  elif author == "aristotle":
    aristotle_quotes.append(quote)

print("Socrates")
print(socrates_quotes)
print("Plato")
print(plato_quotes)
print("Aristotle")
print(aristotle_quotes)
```

:::
:::
